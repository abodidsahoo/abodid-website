import { supabase } from '../supabaseClient';
import type { HubResource, CreateResourcePayload, CuratorApprovalPayload, HubTag, Profile, ResourceAudience } from './types';

// --- Types for Filter Params ---
export interface ResourceFilters {
    query?: string;
    audience?: ResourceAudience | null;
    tags?: string[]; // Array of tag names
    sort?: 'newest' | 'top';
    username?: string; // Filter by curator/submitter
}

// --- Public Access ---

export async function getApprovedResources(filters: ResourceFilters = {}): Promise<HubResource[]> {
    if (!supabase) return [];

    let query = supabase
        .from('hub_resources')
        .select(`
      *,
      submitter_profile:submitted_by (username, full_name, avatar_url),
      tags:hub_resource_tags (
        tag_id,
        tag:hub_tags (name)
      )
    `)
        .eq('status', 'approved');

    // 1. Search (Full Text)
    if (filters.query && filters.query.trim().length > 0) {
        // websearch_to_tsquery handles quotes and -exclusions nicely
        query = query.textSearch('fts', filters.query, {
            type: 'websearch',
            config: 'english'
        });
    }

    if (filters.audience) {
        query = query.eq('audience', filters.audience);
    }

    if (filters.username) {
        // Join on profiles to finding the ID? 
        // Or getting ID first.
        // Let's assume we pass the ID if possible, but username is friendlier for URL
        // Better: 2-step. Get ID for username, then filter.
        // Or: join!
        // Simplest: 2-step in this fn or assume filter.username is handled by caller? 
        // Let's handle it here.
        const { data: profile } = await supabase.from('profiles').select('id').eq('username', filters.username).single();
        if (profile) {
            query = query.eq('submitted_by', profile.id);
        } else {
            return []; // User not found
        }
    }

    // 3. Filter by Tags (Mental Gymnastics: Postgres doesn't make many-to-many filter easy in one go)
    // Approach: If tags interact, we might need a subquery or post-filter.
    // For Stage 2 Scalability: Post-filter is okay for < 1000 items. 
    // For Real Scalability: We'd use `!inner` join on tags but that filters the RETURNED tags too.
    // Better approach: Use the `contains` operator on an array if we had denormalized tags, 
    // OR just select IDs first.
    // Simpler for now: Post-filter in JS (fastest for < 1000 items).

    // 4. Sort
    if (filters.sort === 'top') {
        query = query.order('upvotes_count', { ascending: false });
    } else {
        query = query.order('created_at', { ascending: false });
    }

    const { data, error } = await query;

    if (error) {
        console.error('Error fetching approved resources:', error);
        return [];
    }

    // Transform to flatter structure
    let resources = data.map((item: any) => ({
        ...item,
        tags: item.tags
            ?.map((t: any) => t.tag)
            ?.filter((tag: any) => tag !== null) || []
    }));

    // JS Post-Filter for Tags (if needed)
    if (filters.tags && filters.tags.length > 0) {
        resources = resources.filter((res: any) => {
            const resTagNames = res.tags.map((t: any) => t.name);
            // OR logic: Has at least one matches?
            // AND logic: Has ALL matches?
            // Let's go with OR for now (standard for "explore").
            return filters.tags!.some(filterTag => resTagNames.includes(filterTag));
        });
    }

    return resources;
}

export async function getAllTags(): Promise<HubTag[]> {
    if (!supabase) return [];

    const { data, error } = await supabase
        .from('hub_tags')
        .select('*')
        .order('name', { ascending: true });

    if (error) {
        console.error('Error fetching tags:', error);
        return [];
    }

    return data;
}

export async function searchTags(query: string): Promise<HubTag[]> {
    if (!supabase) return [];

    // RPC call to the function we created in migration
    const { data, error } = await supabase
        .rpc('search_tags', { q: query, lim: 10 });

    if (error) {
        console.error('Error searching tags:', error);
        return [];
    }
    return data;
}

export async function createTag(name: string): Promise<HubTag | null> {
    if (!supabase) return null;

    const { data, error } = await supabase
        .from('hub_tags')
        .insert([{ name }]) // Slug is auto-generated by DB
        .select()
        .single();

    if (error) {
        console.error('Error creating tag:', error);
        return null;
    }
    return data;
}

// --- User Actions ---

export async function submitResource(payload: CreateResourcePayload): Promise<{ success: boolean; error?: string; data?: any }> {
    if (!supabase) return { success: false, error: 'Database not connected' };

    try {
        // 1. Get current user
        const { data: { user } } = await supabase.auth.getUser();
        if (!user) return { success: false, error: 'You must be logged in to submit.' };

        // 1.5. Get user role to determine auto-approval
        const { data: profile } = await supabase
            .from('profiles')
            .select('role')
            .eq('id', user.id)
            .single();

        const userRole = profile?.role || 'user';
        // Auto-approve for curators and admins, pending for regular users
        const submissionStatus = (userRole === 'curator' || userRole === 'admin') ? 'approved' : 'pending';

        // 2. Rate Limit Check (Max 3 per day)
        const oneDayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString();
        const { count, error: countError } = await supabase
            .from('hub_resources')
            .select('id', { count: 'exact', head: true })
            .eq('submitted_by', user.id)
            .gte('created_at', oneDayAgo);

        if (countError) throw countError;
        if (count !== null && count >= 3) {
            return { success: false, error: 'Daily submission limit reached (3/day).' };
        }

        // 3. Insert Resource
        const { data: resource, error: insertError } = await supabase
            .from('hub_resources')
            .insert([{
                title: payload.title,
                url: payload.url,
                description: payload.description,
                audience: 'Designer',
                thumbnail_url: null,
                credit_text: payload.credit_text,
                submitted_by: user.id,
                status: submissionStatus,
                // If auto-approved, set reviewed_at and reviewed_by
                ...(submissionStatus === 'approved' ? {
                    reviewed_at: new Date().toISOString(),
                    reviewed_by: user.id
                } : {})
            }])
            .select()
            .single();

        if (insertError) throw insertError;

        return { success: true, data: resource };

    } catch (e: any) {
        console.error('Submission failed:', e);
        return { success: false, error: e.message || 'Submission failed' };
    }
}

export async function getUserSubmissions(): Promise<HubResource[]> {
    if (!supabase) return [];

    const { data: { user } } = await supabase.auth.getUser();
    if (!user) return [];

    const { data, error } = await supabase
        .from('hub_resources')
        .select('*')
        .eq('submitted_by', user.id)
        .order('created_at', { ascending: false });

    if (error) return [];
    return data;
}

// --- Admin Actions ---

export async function getPendingResources(): Promise<HubResource[]> {
    if (!supabase) return [];

    const { data, error } = await supabase
        .from('hub_resources')
        .select(`
      *,
      submitter_profile:submitted_by (username, full_name, avatar_url),
      tags:hub_resource_tags (
        tag_id,
        tag:hub_tags (id, name)
      )
    `)
        .in('status', ['pending']) // Explicitly only pending
        .order('created_at', { ascending: true });

    if (error) {
        console.error('Error fetching pending resources:', error);
        return [];
    }

    return data.map((item: any) => ({
        ...item,
        tags: item.tags
            ?.map((t: any) => t.tag)
            ?.filter((tag: any) => tag !== null) || []
    }));
}

export async function updateResourceStatus(
    resourceId: string,
    status: 'approved' | 'rejected' | 'pending' | 'deleted',
    adminNotes?: string
): Promise<{ success: boolean; error?: string }> {
    if (!supabase) return { success: false, error: 'Database not connected' };

    try {
        const { data: { user } } = await supabase.auth.getUser();
        if (!user) return { success: false, error: 'Unauthorized' };

        const updates: any = {
            status,
            reviewed_at: new Date().toISOString(),
            reviewed_by: user.id
        };

        if (adminNotes) {
            updates.admin_notes = adminNotes;
        }

        const { error } = await supabase
            .from('hub_resources')
            .update(updates)
            .eq('id', resourceId);

        if (error) throw error;
        return { success: true };

    } catch (e: any) {
        console.error('Status update failed:', e);
        return { success: false, error: e.message };
    }
}

export async function updateResource(
    resourceId: string,
    payload: CreateResourcePayload
): Promise<{ success: boolean; error?: string }> {
    if (!supabase) return { success: false, error: 'Database not connected' };

    try {
        const { data: { user } } = await supabase.auth.getUser();
        if (!user) return { success: false, error: 'Unauthorized' };

        // 1. Update Core Data
        const { error: updateError } = await supabase
            .from('hub_resources')
            .update({
                title: payload.title,
                url: payload.url,
                description: payload.description,
                audience: payload.audience,
                thumbnail_url: payload.thumbnail_url,
                credit_text: payload.credit_text,
                updated_at: new Date().toISOString()
            })
            .eq('id', resourceId);

        if (updateError) throw updateError;

        // 2. Sync Tags (Delete All + Re-insert) implementation strategy
        // Only do this if tag_ids are provided
        if (payload.tag_ids) {
            // Delete existing links
            await supabase
                .from('hub_resource_tags')
                .delete()
                .eq('resource_id', resourceId);

            // Insert new
            if (payload.tag_ids.length > 0) {
                const tagInserts = payload.tag_ids.map(tagId => ({
                    resource_id: resourceId,
                    tag_id: tagId
                }));

                const { error: tagError } = await supabase
                    .from('hub_resource_tags')
                    .insert(tagInserts);

                if (tagError) console.warn('Tag sync error', tagError);
            }
        }

        return { success: true };

    } catch (e: any) {
        console.error('Update failed:', e);
        return { success: false, error: e.message };
    }
}

export async function getCurrentProfile(): Promise<Profile | null> {
    if (!supabase) return null;
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) return null;

    const { data } = await supabase
        .from('profiles')
        .select('*')
        .eq('id', user.id)
        .single();

    return data;
}

export async function getProfileByUsername(username: string): Promise<Profile | null> {
    if (!supabase) return null;
    const { data, error } = await supabase
        .from('profiles')
        .select('*')
        .eq('username', username)
        .single();

    if (error) return null;
    return data;
}

// --- Social Actions (Bookmarks & Upvotes) ---

export async function getMyBookmarks(): Promise<string[]> {
    if (!supabase) return [];
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) return [];

    const { data } = await supabase
        .from('hub_resource_bookmarks')
        .select('resource_id')
        .eq('user_id', user.id);

    return data ? data.map(d => d.resource_id) : [];
}

export async function getMyUpvotes(): Promise<string[]> {
    if (!supabase) return [];
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) return [];

    const { data } = await supabase
        .from('hub_resource_upvotes')
        .select('resource_id')
        .eq('user_id', user.id);

    return data ? data.map(d => d.resource_id) : [];
}

export async function toggleBookmark(resourceId: string): Promise<{ bookmarked: boolean }> {
    if (!supabase) throw new Error('DB not connected');
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) throw new Error('Must be logged in');

    // Check if exists
    const { data } = await supabase
        .from('hub_resource_bookmarks')
        .select('*')
        .eq('user_id', user.id)
        .eq('resource_id', resourceId)
        .single();

    if (data) {
        // Remove
        await supabase
            .from('hub_resource_bookmarks')
            .delete()
            .eq('user_id', user.id)
            .eq('resource_id', resourceId);
        return { bookmarked: false };
    } else {
        // Add
        await supabase
            .from('hub_resource_bookmarks')
            .insert([{ user_id: user.id, resource_id: resourceId }]);
        return { bookmarked: true };
    }
}

export async function toggleUpvote(resourceId: string): Promise<{ upvoted: boolean }> {
    if (!supabase) throw new Error('DB not connected');
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) throw new Error('Must be logged in');

    // Check if exists
    const { data } = await supabase
        .from('hub_resource_upvotes')
        .select('*')
        .eq('user_id', user.id)
        .eq('resource_id', resourceId)
        .single();

    if (data) {
        // Remove
        await supabase
            .from('hub_resource_upvotes')
            .delete()
            .eq('user_id', user.id)
            .eq('resource_id', resourceId);
        return { upvoted: false };
    } else {
        // Add
        await supabase
            .from('hub_resource_upvotes')
            .insert([{ user_id: user.id, resource_id: resourceId }]);
        return { upvoted: true };
    }
}

export async function getBookmarkedResources(userId: string): Promise<HubResource[]> {
    if (!supabase) return [];

    // 1. Get IDs
    const { data: bookmarks } = await supabase
        .from('hub_resource_bookmarks')
        .select('resource_id')
        .eq('user_id', userId);

    if (!bookmarks || bookmarks.length === 0) return [];

    const ids = bookmarks.map(b => b.resource_id);

    // 2. Fetch Resources
    const { data, error } = await supabase
        .from('hub_resources')
        .select(`
          *,
          submitter_profile:submitted_by (username, full_name, avatar_url),
          tags:hub_resource_tags (
            tag_id,
            tag:hub_tags (name)
          )
        `)
        .in('id', ids)
        .eq('status', 'approved'); // Only approved? Usually yes.

    if (error) return [];

    let resources = data.map((item: any) => ({
        ...item,
        tags: item.tags.map((t: any) => t.tag)
    }));

    return resources;
}

export async function getUserStats(userId: string): Promise<{ recent_upvotes: number; total_bookmarks: number }> {
    if (!supabase) return { recent_upvotes: 0, total_bookmarks: 0 };

    const twoMonthsAgo = new Date();
    twoMonthsAgo.setMonth(twoMonthsAgo.getMonth() - 2);

    const { count: upvotesCount } = await supabase
        .from('hub_resource_upvotes')
        .select('*', { count: 'exact', head: true })
        .eq('user_id', userId)
        .gte('created_at', twoMonthsAgo.toISOString());

    const { count: bookmarksCount } = await supabase
        .from('hub_resource_bookmarks')
        .select('*', { count: 'exact', head: true })
        .eq('user_id', userId);

    return {
        recent_upvotes: upvotesCount || 0,
        total_bookmarks: bookmarksCount || 0
    };
}

// --- Curator Moderation Actions ---

export async function approveResource(
    resourceId: string,
    payload: CuratorApprovalPayload = {}
): Promise<{ success: boolean; error?: string }> {
    if (!supabase) return { success: false, error: 'Database not connected' };

    try {
        const { data: { user } } = await supabase.auth.getUser();
        if (!user) return { success: false, error: 'Unauthorized' };

        const updates: any = {
            status: 'approved',
            reviewed_at: new Date().toISOString(),
            reviewed_by: user.id,
            updated_at: new Date().toISOString()
        };

        if (payload.thumbnail_url !== undefined) {
            updates.thumbnail_url = payload.thumbnail_url;
        }

        if (payload.audience) {
            updates.audience = payload.audience;
        }

        const { error: resourceError } = await supabase
            .from('hub_resources')
            .update(updates)
            .eq('id', resourceId);

        if (resourceError) throw resourceError;

        if (payload.tag_ids) {
            const { error: deleteTagsError } = await supabase
                .from('hub_resource_tags')
                .delete()
                .eq('resource_id', resourceId);

            if (deleteTagsError) throw deleteTagsError;

            if (payload.tag_ids.length > 0) {
                const tagInserts = payload.tag_ids.map(tagId => ({
                    resource_id: resourceId,
                    tag_id: tagId
                }));

                const { error: insertTagsError } = await supabase
                    .from('hub_resource_tags')
                    .insert(tagInserts);

                if (insertTagsError) throw insertTagsError;
            }
        }

        return { success: true };
    } catch (e: any) {
        console.error('Approval failed:', e);
        return { success: false, error: e.message };
    }
}

export async function rejectResource(resourceId: string, reason?: string): Promise<{ success: boolean; error?: string }> {
    if (!supabase) return { success: false, error: 'Database not connected' };

    try {
        const { data: { user } } = await supabase.auth.getUser();
        if (!user) return { success: false, error: 'Unauthorized' };

        const updates: any = {
            status: 'rejected',
            reviewed_at: new Date().toISOString(),
            reviewed_by: user.id,
            rejection_reason: reason || 'No reason provided'
        };

        const { error } = await supabase
            .from('hub_resources')
            .update(updates)
            .eq('id', resourceId);

        if (error) throw error;
        return { success: true };

    } catch (e: any) {
        console.error('Rejection failed:', e);
        return { success: false, error: e.message };
    }
}

export async function deleteResource(resourceId: string): Promise<{ success: boolean; error?: string }> {
    if (!supabase) return { success: false, error: 'Database not connected' };

    try {
        const { data: { user } } = await supabase.auth.getUser();
        if (!user) return { success: false, error: 'Unauthorized' };

        // Verify Admin Role
        const { data: profile } = await supabase.from('profiles').select('role').eq('id', user.id).single();
        if (profile?.role !== 'admin') {
            return { success: false, error: 'Only admins can delete resources.' };
        }

        // SOFT DELETE: Update status to 'deleted'
        const { error } = await supabase
            .from('hub_resources')
            .update({ status: 'deleted', reviewed_at: new Date().toISOString(), reviewed_by: user.id })
            .eq('id', resourceId);

        if (error) throw error;
        return { success: true };

    } catch (e: any) {
        console.error('Soft Deletion failed:', e);
        return { success: false, error: e.message };
    }
}

export async function restoreResource(resourceId: string): Promise<{ success: boolean; error?: string }> {
    if (!supabase) return { success: false, error: 'Database not connected' };

    try {
        const { data: { user } } = await supabase.auth.getUser();
        if (!user) return { success: false, error: 'Unauthorized' };

        const { data: profile } = await supabase.from('profiles').select('role').eq('id', user.id).single();
        if (profile?.role !== 'admin') {
            return { success: false, error: 'Only admins can restore resources.' };
        }

        // Restore to pending
        const { error } = await supabase
            .from('hub_resources')
            .update({ status: 'pending', reviewed_at: new Date().toISOString(), reviewed_by: user.id })
            .eq('id', resourceId);

        if (error) throw error;
        return { success: true };

    } catch (e: any) {
        console.error('Restore failed:', e);
        return { success: false, error: e.message };
    }
}

export async function permanentDeleteResource(resourceId: string): Promise<{ success: boolean; error?: string }> {
    if (!supabase) return { success: false, error: 'Database not connected' };

    try {
        const { data: { user } } = await supabase.auth.getUser();
        if (!user) return { success: false, error: 'Unauthorized' };

        const { data: profile } = await supabase.from('profiles').select('role').eq('id', user.id).single();
        if (profile?.role !== 'admin') {
            return { success: false, error: 'Only admins can permanently delete resources.' };
        }

        const { error } = await supabase
            .from('hub_resources')
            .delete()
            .eq('id', resourceId);

        if (error) throw error;
        return { success: true };

    } catch (e: any) {
        console.error('Permanent Deletion failed:', e);
        return { success: false, error: e.message };
    }
}

export async function getDeletedResources(): Promise<HubResource[]> {
    if (!supabase) return [];

    const { data: { user } } = await supabase.auth.getUser();
    if (!user) return [];

    // Verify Admin
    const { data: profile } = await supabase.from('profiles').select('role').eq('id', user.id).single();
    if (profile?.role !== 'admin') return [];

    const { data, error } = await supabase
        .from('hub_resources')
        .select(`
      *,
      submitter_profile:submitted_by (username, full_name, avatar_url)
    `)
        .eq('status', 'deleted')
        .order('reviewed_at', { ascending: false }); // Show most recently deleted first

    if (error) {
        console.error('Error fetching deleted resources:', error);
        return [];
    }

    return data;
}

export async function getAllResourcesAdmin(): Promise<HubResource[]> {
    if (!supabase) return [];

    const { data: { user } } = await supabase.auth.getUser();
    if (!user) return [];

    // Verify Admin
    const { data: profile } = await supabase.from('profiles').select('role').eq('id', user.id).single();
    if (profile?.role !== 'admin') return [];

    const { data, error } = await supabase
        .from('hub_resources')
        .select(`
      *,
      submitter_profile:submitted_by (username, full_name, avatar_url)
    `)
        .neq('status', 'deleted') // Exclude deleted (trash)
        .order('created_at', { ascending: false });

    if (error) {
        console.error('Error fetching all resources:', error);
        return [];
    }

    return data;
}
