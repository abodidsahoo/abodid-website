---
import { getAllPhotography } from "../../lib/api";

// Fetch real photography data
const sourceImages = await getAllPhotography();

// Flatten and expand for density (Infinite feel requires many items)
const rawImages = sourceImages.map((item) => ({
    url:
        item.cover_image ||
        item.image ||
        "https://images.unsplash.com/photo-1542273917363-3b1817f69a2d",
    story: item.title || "Untitled Memory",
}));

// Create a larger dataset by repeating
const images = [
    ...rawImages,
    ...rawImages,
    ...rawImages,
    ...rawImages,
    ...rawImages,
    ...rawImages,
];
---

<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Infinite Archive</title>
        <link rel="preconnect" href="https://fonts.googleapis.com" />
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
        <link
            href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500&display=swap"
            rel="stylesheet"
        />
        <style>
            /* Reset & Core Stats */
            :global(body) {
                margin: 0;
                padding: 0;
                overflow: hidden;
                background: #000;
                font-family: "Poppins", sans-serif;
                -webkit-font-smoothing: antialiased;
            }

            :global(*) {
                box-sizing: border-box;
            }
        </style>
    </head>
    <body>
        <div class="infinite-container">
            <!-- Close Button -->
            <a
                href="/visual-experiments"
                class="close-button"
                aria-label="Close"
            >
                <svg
                    width="24"
                    height="24"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    stroke-width="2"
                >
                    <line x1="18" y1="6" x2="6" y2="18"></line>
                    <line x1="6" y1="6" x2="18" y2="18"></line>
                </svg>
            </a>

            <!-- 3D Scene Viewport -->
            <div class="scene-viewport" id="viewport">
                <div class="tunnel-world" id="world">
                    {
                        images.map((img, i) => {
                            // Sequential Z for Tunnel
                            const zPos = -i * 600;
                            // Random X/Y scatter (Screen Space Billboards)
                            // Range: -800 to 800 roughly
                            const xPos = (Math.random() - 0.5) * 1600;
                            const yPos = (Math.random() - 0.5) * 1000;

                            return (
                                <div
                                    class="tunnel-card"
                                    data-story={img.story}
                                    style={`
                                    --x: ${xPos}px;
                                    --y: ${yPos}px;
                                    --z: ${zPos}px;
                                    background-image: url('${img.url}?auto=format&fit=crop&w=600&q=80');
                                `}
                                />
                            );
                        })
                    }
                </div>
            </div>

            <!-- Navigator HUD (Bottom Center) -->
            <div class="navigator-hud" id="navigator">
                <div class="nav-pad">
                    <div class="nav-stick" id="nav-stick"></div>
                </div>
            </div>

            <!-- Focus Overlay -->
            <div class="focus-overlay" id="focus-overlay">
                <div class="focused-card" id="focused-card"></div>
                <div class="focused-story" id="focused-story">
                    <p id="story-text"></p>
                </div>
            </div>
        </div>

        <script>
            const world = document.getElementById("world");
            const navHud = document.getElementById("navigator");
            const navStick = document.getElementById("nav-stick");

            const focusOverlay = document.getElementById("focus-overlay");
            const focusedCard = document.getElementById("focused-card");
            const storyText = document.getElementById("story-text");
            const cards = document.querySelectorAll(".tunnel-card");

            // --- Physics State ---
            const physics = {
                posZ: 0,
                posX: 0,
                velZ: 1.5, // Default Cruise Speed
                velX: 0,
                targetVelZ: 1.5,
                targetVelX: 0,
                mouseX: 0,
                mouseY: 0,
                lastTime: 0,
                isDragging: false,
                isFocused: false,
            };

            const config = {
                acceleration: 0.08,
                sensitivity: 0.35,
                parallaxStrength: 5, // Subtle
            };

            // --- Navigator Logic ---
            let dragStart = { x: 0, y: 0 };

            navHud.addEventListener("mousedown", (e) => {
                if (physics.isFocused) return;
                physics.isDragging = true;
                dragStart.x = e.clientX;
                dragStart.y = e.clientY;
                navHud.classList.add("active");

                // Update Stick immediately
                updateStick(e.clientX, e.clientY);
            });

            window.addEventListener("mouseup", () => {
                physics.isDragging = false;
                navHud.classList.remove("active");
                navStick.style.transform = "translate(0px, 0px)";

                // Reset targets
                physics.targetVelZ = 1.5;
                physics.targetVelX = 0;
            });

            window.addEventListener("mousemove", (e) => {
                // Parallax
                physics.mouseX = e.clientX / window.innerWidth - 0.5;
                physics.mouseY = e.clientY / window.innerHeight - 0.5;

                if (!physics.isDragging) return;

                updateStick(e.clientX, e.clientY);

                const deltaX = e.clientX - dragStart.x;
                const deltaY = e.clientY - dragStart.y;

                // Map inputs
                // Drag Up (-Y) -> Faster (+Z)
                // Drag Down (+Y) -> Slower/Reverse (-Z)

                // Clamp
                const xVal = Math.max(-100, Math.min(100, deltaX));
                const yVal = Math.max(-100, Math.min(100, deltaY));

                physics.targetVelZ = 1.5 - yVal * config.sensitivity;
                physics.targetVelX = -(xVal * config.sensitivity * 0.5);
            });

            function updateStick(mx, my) {
                let dx = mx - dragStart.x;
                let dy = my - dragStart.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const max = 40;
                if (dist > max) {
                    const angle = Math.atan2(dy, dx);
                    dx = Math.cos(angle) * max;
                    dy = Math.sin(angle) * max;
                }
                navStick.style.transform = `translate(${dx}px, ${dy}px)`;
            }

            // --- Game Loop ---
            function update(time) {
                if (!physics.lastTime) physics.lastTime = time;
                const dt = (time - physics.lastTime) / 16.67;
                physics.lastTime = time;

                if (!physics.isFocused) {
                    // Smooth interpolate velocity
                    physics.velZ +=
                        (physics.targetVelZ - physics.velZ) *
                        config.acceleration *
                        dt;
                    physics.velX +=
                        (physics.targetVelX - physics.velX) *
                        config.acceleration *
                        dt;

                    // Apply position
                    physics.posZ += physics.velZ * dt;
                    physics.posX += physics.velX * dt;
                }

                if (world) {
                    // World moves opposite to camera
                    // Parallax via Rotate
                    const rotY = -physics.mouseX * config.parallaxStrength;
                    const rotX = physics.mouseY * config.parallaxStrength;

                    world.style.transform = `
                        translate3d(${-physics.posX}px, 0, ${physics.posZ}px)
                        rotateX(${rotX}deg) rotateY(${rotY}deg)
                    `;
                }

                // Infinite Loop / Culling logic mostly handled by CSS separation
                // We can add logic to warp items from back to front if needed for true infinite,
                // but with 100+ items and deep Z, linear is fine for a long session.

                // Optional: Fade out items behind camera (Z > 500 relative)
                // item.z + posZ > 200
                cards.forEach((card) => {
                    const rawZ = parseFloat(
                        getComputedStyle(card).getPropertyValue("--z"),
                    );
                    const dist = rawZ + physics.posZ;
                    if (dist > 300) card.style.opacity = "0";
                    else if (dist < -2000) card.style.opacity = "0.5";
                    else card.style.opacity = "1";
                });

                requestAnimationFrame(update);
            }
            requestAnimationFrame(update);

            // --- Focus Logic (FLIP) ---
            let originCard = null;

            cards.forEach((card) => {
                card.addEventListener("click", () => {
                    if (physics.isFocused) return;

                    originCard = card;
                    enterFocus(card);
                });
            });

            function enterFocus(card) {
                physics.isFocused = true;
                physics.velZ = 0; // Stop world

                const rect = card.getBoundingClientRect();
                const url = getComputedStyle(card).backgroundImage;
                const story = card.getAttribute("data-story");

                // Init Overlay
                focusOverlay.style.display = "block";
                focusedCard.style.backgroundImage = url;
                storyText.innerText = story;

                // 1. Set Start Position
                focusedCard.style.transition = "none";
                focusedCard.style.transform = `translate(${rect.left}px, ${rect.top}px)`;
                focusedCard.style.width = `${rect.width}px`;
                focusedCard.style.height = `${rect.height}px`;

                // Force Reflow
                focusedCard.getBoundingClientRect();

                // 2. Animate to Center
                requestAnimationFrame(() => {
                    focusOverlay.classList.add("active");
                    focusedCard.classList.add("centered");

                    focusedCard.style.transition =
                        "transform 0.6s cubic-bezier(0.1, 0.9, 0.2, 1), width 0.6s, height 0.6s";

                    const vw = window.innerWidth;
                    const vh = window.innerHeight;
                    const targetW = Math.min(vw * 0.8, 500); // Max 500px width
                    const targetH = Math.min(vh * 0.7, 700); // Max 700px height

                    const targetX = (vw - targetW) / 2;
                    const targetY = (vh - targetH) / 2;

                    focusedCard.style.width = `${targetW}px`;
                    focusedCard.style.height = `${targetH}px`;
                    focusedCard.style.transform = `translate(${targetX}px, ${targetY}px)`;
                });
            }

            // Exit Logic
            focusOverlay.addEventListener("click", (e) => {
                // Click anywhere on overlay to close
                exitFocus();
            });

            function exitFocus() {
                if (!originCard) return;

                focusOverlay.classList.remove("active");
                focusedCard.classList.remove("centered");

                // Animate back to origin
                const rect = originCard.getBoundingClientRect();

                focusedCard.style.width = `${rect.width}px`;
                focusedCard.style.height = `${rect.height}px`;
                focusedCard.style.transform = `translate(${rect.left}px, ${rect.top}px)`;

                setTimeout(() => {
                    focusOverlay.style.display = "none";
                    physics.isFocused = false;
                    physics.targetVelZ = 1.5; // Resume
                    originCard = null;
                }, 500);
            }
        </script>

        <style>
            .infinite-container {
                position: fixed;
                width: 100vw;
                height: 100vh;
                perspective: 800px;
                background: #000;
            }

            /* Close Button */
            .close-button {
                position: absolute;
                top: 2rem;
                right: 2rem;
                width: 44px;
                height: 44px;
                display: flex;
                align-items: center;
                justify-content: center;
                color: rgba(255, 255, 255, 0.6);
                border: 1px solid rgba(255, 255, 255, 0.2);
                border-radius: 50%;
                z-index: 1000;
                transition: all 0.2s ease;
                cursor: pointer;
            }
            .close-button:hover {
                color: #fff;
                border-color: #fff;
                background: rgba(255, 255, 255, 0.1);
            }

            /* 3D Scene */
            .scene-viewport {
                width: 100%;
                height: 100%;
                transform-style: preserve-3d;
            }

            .tunnel-world {
                width: 100%;
                height: 100%;
                position: absolute;
                transform-style: preserve-3d;
                will-change: transform;
            }

            .tunnel-card {
                position: absolute;
                top: 50%;
                left: 50%;
                width: 300px;
                aspect-ratio: 4/5;
                margin-left: -150px;
                margin-top: -187px;
                background-color: #111;
                background-size: cover;
                background-position: center;
                transform: translate3d(var(--x), var(--y), var(--z));
                /* Important: Pure Billboard facing front. No rotations on item. */
                box-shadow: 0 10px 40px rgba(0, 0, 0, 0.8);
                border: 1px solid rgba(255, 255, 255, 0.1);
                transition:
                    border-color 0.3s,
                    box-shadow 0.3s,
                    opacity 0.5s;
                cursor: pointer;
            }

            .tunnel-card:hover {
                border-color: rgba(255, 255, 255, 0.8);
                box-shadow: 0 0 30px rgba(255, 255, 255, 0.3);
            }

            /* Navigator */
            .navigator-hud {
                position: absolute;
                bottom: 3rem;
                left: 50%;
                transform: translateX(-50%);
                width: 100px;
                height: 100px;
                z-index: 200;
                display: flex;
                justify-content: center;
                align-items: center;
            }

            .nav-pad {
                width: 100%;
                height: 100%;
                border-radius: 50%;
                border: 1px solid rgba(255, 255, 255, 0.15);
                background: rgba(255, 255, 255, 0.05);
                backdrop-filter: blur(10px);
                position: relative;
                cursor: pointer;
                transition: border-color 0.2s;
            }
            .navigator-hud.active .nav-pad {
                border-color: rgba(255, 255, 255, 0.5);
                background: rgba(255, 255, 255, 0.1);
            }

            .nav-stick {
                width: 32px;
                height: 32px;
                border-radius: 50%;
                background: rgba(255, 255, 255, 0.9);
                position: absolute;
                top: 50%;
                left: 50%;
                margin-top: -16px;
                margin-left: -16px;
                box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
                pointer-events: none;
                transition: transform 0.1s;
            }

            /* Overlay */
            .focus-overlay {
                position: fixed;
                inset: 0;
                z-index: 500;
                display: none;
                background: rgba(0, 0, 0, 0);
                backdrop-filter: blur(0px);
                transition:
                    background 0.6s,
                    backdrop-filter 0.6s;
            }
            .focus-overlay.active {
                background: rgba(0, 0, 0, 0.85);
                backdrop-filter: blur(12px);
            }

            .focused-card {
                position: absolute;
                top: 0;
                left: 0;
                background-color: #000;
                background-size: cover;
                background-position: center;
                border-radius: 4px;
                box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
                cursor: zoom-out;
            }
            .focused-card.centered {
                border-radius: 12px;
                box-shadow: 0 40px 100px rgba(0, 0, 0, 0.9);
                border: 1px solid rgba(255, 255, 255, 0.1);
            }

            .focused-story {
                position: absolute;
                bottom: 10%;
                left: 0;
                width: 100%;
                text-align: center;
                padding: 0 2rem;
                opacity: 0;
                transform: translateY(20px);
                transition: all 0.6s ease 0.2s;
            }
            .focus-overlay.active .focused-story {
                opacity: 1;
                transform: translateY(0);
            }

            #story-text {
                color: #fff;
                font-size: 1.1rem;
                line-height: 1.6;
                font-weight: 300;
                max-width: 600px;
                margin: 0 auto;
                text-shadow: 0 2px 10px rgba(0, 0, 0, 0.8);
            }
        </style>
    </body>
</html>
