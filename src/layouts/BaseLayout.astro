---
import "../styles/global.css";
import "../styles/brands.css";
import Header from "../components/Header.jsx";
import Footer from "../components/Footer.astro";
import SEO from "../components/SEO.astro";
import StickyMobileNav from "../components/StickyMobileNav.jsx";
import NewsletterPopup from "../components/NewsletterPopup.jsx";
import MagneticCursorFollower from "../components/MagneticCursorFollower.jsx";
import { getPageMetadata } from "../lib/api";

const {
  title,
  description,
  image,
  type,
  hideHeader = false,
  hideFooter = false,
  fullWidth = false,
  showStickyNav = true,
  showNewsletterPopup = true,
  showGlobalGrid = true,
  bodyClass = "",
  showCursor,
  showCursorFollower = true,
  gridVariant = "default",
} = Astro.props;
import NoiseOverlay from "../components/NoiseOverlay.jsx";
const cursorFollowerEnabled =
  typeof showCursor === "boolean" ? showCursor : showCursorFollower;

// Fetch metadata from database if not provided via props
const pagePath = Astro.url.pathname;
const dbMetadata = await getPageMetadata(pagePath);
const finalTitle = title || dbMetadata?.meta_title || dbMetadata?.page_title;
const finalDescription = description || dbMetadata?.meta_description;
const finalImage = image || dbMetadata?.og_image_url;
const finalType = type || dbMetadata?.og_type || "website";
---

<html lang="en">
  <head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-V07Z22DSVH"></script>
    <script is:inline>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-V07Z22DSVH');
    </script>
    <meta charset="utf-8" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <meta name="viewport" content="width=device-width" />
    <meta name="generator" content={Astro.generator} />
    <link
      rel="alternate"
      type="application/rss+xml"
      title="Abodid Blog"
      href="/rss.xml"
    />

    <!-- Google Fonts: Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&display=swap"
      rel="stylesheet"
    />

    <link
      href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700;800&display=swap"
      rel="stylesheet"
    />

    <link
      href="https://fonts.googleapis.com/css2?family=Inconsolata:wght@400;700&display=swap"
      rel="stylesheet"
    />

    <link
      href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />

    <link
      href="https://fonts.googleapis.com/css2?family=Pixelify+Sans:wght@400..700&display=swap"
      rel="stylesheet"
    />

    <link
      href="https://fonts.googleapis.com/css2?family=VT323&display=swap"
      rel="stylesheet"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Crimson+Pro:ital,wght@0,300..700;1,300..700&display=swap"
      rel="stylesheet"
    />

    <SEO
      title={finalTitle}
      description={finalDescription}
      image={finalImage}
      type={finalType}
    />
    <!-- Dynamic SEO & Social Images applied -->
    <slot name="head" />

    <!-- Theme Initialization to prevent FOUC -->
    <script is:inline>
      (function () {
        const prefersLight =
          window.matchMedia &&
          window.matchMedia("(prefers-color-scheme: light)").matches;

        let nextTheme = prefersLight ? "light" : "dark";
        try {
          const savedTheme = localStorage.getItem("theme");
          if (savedTheme === "light" || savedTheme === "dark") {
            nextTheme = savedTheme;
          } else {
            localStorage.setItem("theme", nextTheme);
          }
        } catch (_error) {
          // no-op
        }

        document.documentElement.setAttribute("data-theme", nextTheme);
        document.documentElement.style.colorScheme = nextTheme;
      })();
    </script>
  </head>
  <body data-grid-variant={gridVariant} data-page-path={pagePath} class={bodyClass}>
    <a href="#main-content" class="skip-link">Skip to main content</a>
    <!-- <Header /> -->
    <!-- Header: client:load for immediate hydration priority -->
    {!hideHeader && <Header client:load />}
    {showGlobalGrid && <div class="global-grid-bg"></div>}
    {showGlobalGrid && <div class="global-glow-bg"></div>}
    <main
      id="main-content"
      class={`${fullWidth ? "page-content-full" : "container page-content"} ${!hideHeader ? "header-padding" : ""}`}
    >
      <slot />
    </main>
    {showStickyNav && <StickyMobileNav client:idle />}
    {showNewsletterPopup && <NewsletterPopup client:only="react" />}
    {cursorFollowerEnabled && <MagneticCursorFollower client:load />}

    {/* Global Grain Disabled by default, can be enabled via props if needed */}
    {/* <NoiseOverlay client:only="react" opacity={0.05} /> */}

    <script src="/scripts/journey-tracker.js" defer></script>
    {!hideFooter && <Footer />}
  </body>
</html>

<style>
  body {
    /* Background handled by global.css theme variables */
  }

  .page-content {
    /* Padding handled by .header-padding if header visible */
    padding-bottom: 6rem;
    position: relative;
    z-index: 1; /* Ensure content is above grid */
  }

  .page-content-full {
    padding: 0;
    width: 100vw;
    position: relative;
    z-index: 1;
  }

  /* Universal Header Clearance Rule */
  /* Applied if !hideHeader is true */
  .header-padding {
    padding-top: 140px !important; /* 80px header + 60px safe buffer */
  }

  .global-grid-bg {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    z-index: 0; /* Behind content but check base layout stacking */
    pointer-events: none;

    /* Subtle Grid Background */
    background-image:
      linear-gradient(to right, var(--grid-color-2) 1px, transparent 1px),
      linear-gradient(to bottom, var(--grid-color-2) 1px, transparent 1px);
    background-size: 60px 60px; /* PERFECT SQUARE as requested */
    background-position: center top;

    /* Soft fade on edges */
    -webkit-mask-image: radial-gradient(
      ellipse at center,
      black 30%,
      transparent 80%
    );
    mask-image: radial-gradient(ellipse at center, black 30%, transparent 80%);
  }

  /* Ensure Footer is above grid */
  :global(.site-footer) {
    position: relative;
    z-index: 10;
    background-color: var(--bg-surface);
  }

  .global-glow-bg {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    z-index: 0; /* Same layer as grid, interactions managed by opacity */
    pointer-events: none;
    opacity: var(--glow-intensity, 1);
    transition: opacity 0.3s ease-out;

    /* Brighter Grid for Glow - Reduced power */
    background-image:
      linear-gradient(to right, var(--grid-color-1) 1px, transparent 1px),
      linear-gradient(to bottom, var(--grid-color-1) 1px, transparent 1px);
    background-size: 60px 60px; /* PERFECT SQUARE */
    background-position: center top;

    /* Reveal only near mouse AND faded at edges (Global Mask) */
    -webkit-mask-image:
      radial-gradient(
        circle var(--glow-radius, 300px) at var(--mouse-x, -500px)
          var(--mouse-y, -500px),
        black,
        transparent
      ),
      radial-gradient(ellipse at center, black 30%, transparent 80%);
    mask-image:
      radial-gradient(
        circle var(--glow-radius, 300px) at var(--mouse-x, -500px)
          var(--mouse-y, -500px),
        black,
        transparent
      ),
      radial-gradient(ellipse at center, black 30%, transparent 80%);

    /* Composite: Intersect them so glow fades at edges */
    -webkit-mask-composite: source-in;
    mask-composite: intersect;
  }

  .skip-link {
    position: absolute;
    top: -40px;
    left: 0;
    background: #000;
    color: #fff;
    padding: 8px;
    z-index: 9999;
    transition: top 0.2s;
  }

  .skip-link:focus {
    top: 0;
  }

  :global(.global-stability-notice) {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 10030;
    pointer-events: none;
    max-width: min(560px, 86vw);
    padding: 16px 20px;
    border-radius: 12px;
    border: 1px solid rgba(0, 0, 0, 0.14);
    background: rgba(255, 255, 255, 0.96);
    backdrop-filter: blur(10px);
    box-shadow: 0 12px 40px rgba(0, 0, 0, 0.18);
    text-align: center;
    opacity: 0;
    visibility: hidden;
    transition:
      opacity 0.25s ease,
      visibility 0.25s ease;
  }

  :global(.global-stability-notice.visible) {
    opacity: 1;
    visibility: visible;
  }

  :global(.global-stability-notice p) {
    margin: 0;
    color: rgba(0, 0, 0, 0.86);
    font-family: var(--font-ui);
    font-size: 0.86rem;
    letter-spacing: 0.03em;
    line-height: 1.45;
  }
</style>

<script>
  function initGlobalEffects() {
    const glowBg = document.querySelector(".global-glow-bg") as HTMLElement;
    if (!glowBg) return;
    const gridVariant = document.body?.dataset?.gridVariant || "default";

    // Mouse Tracking
    window.addEventListener(
      "mousemove",
      (e) => {
        glowBg.style.setProperty("--mouse-x", `${e.clientX}px`);
        glowBg.style.setProperty("--mouse-y", `${e.clientY}px`);
      },
      { passive: true },
    );

    // Scroll Intensity Tracking
    const updateIntensity = () => {
      // Universal Glow - Apply logic to all pages
      // Check if we are on the homepage for specific intensity tuning if needed,
      // but user requested "universal pointer for all pages".

      const isHome =
        window.location.pathname === "/" ||
        window.location.pathname === "" ||
        window.location.pathname === "/test-landing";

      // Base intensity for all pages
      let baseIntensity = 1.0;

      // If NOT home, maybe we want it slightly less intense?
      // User said "universal pointer", "affect things in this testimonial page".
      // Let's keep it consistent but maybe respect the scroll fade only on Home if it has the typewriter?
      // Or just let it be persistent.

      // Let's try enabling it fully first.
      // We'll use the scroll logic only for Home (fade out) but keep it active on others.

      if (!isHome) {
        const variantIntensity = gridVariant === "moodboard" ? "1" : "0.8";
        glowBg.style.setProperty("--glow-intensity", variantIntensity);
        return; // EXIT HERE so scroll logic doesn't override it
      }

      // Homepage Logic: Targeted for typewriter area (top)
      // ...

      // Homepage Logic: Targeted for typewriter area (top)
      const scrollY = window.scrollY;
      const windowHeight = window.innerHeight;

      // Faster fade out to ensure it's mainly for the top area
      const fadeDistance = windowHeight * 1.0;
      const minIntensity = 0.05; // "Hardly visible"

      let intensity = 1 - scrollY / fadeDistance;
      if (intensity < minIntensity) intensity = minIntensity;

      glowBg.style.setProperty("--glow-intensity", intensity.toString());
    };

    window.addEventListener("scroll", updateIntensity, { passive: true });
    updateIntensity(); // Initial call
  }

  // Init
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initGlobalEffects);
  } else {
    initGlobalEffects();
  }

  function initRenderStabilityWatchdog() {
    const main = document.getElementById("main-content");
    if (!main) return;

    const notice = document.createElement("div");
    notice.className = "global-stability-notice";
    notice.setAttribute("role", "status");
    notice.setAttribute("aria-live", "polite");
    notice.innerHTML =
      "<p>Something looks off. Kindly refresh the page for a finetuned experience.</p>";
    document.body.appendChild(notice);

    let hadVisibleMainContent = false;
    let runtimeErrorSeen = false;
    let anomalyStreak = 0;
    let healthyStreak = 0;

    const showNotice = () => notice.classList.add("visible");
    const hideNotice = () => notice.classList.remove("visible");

    const onRuntimeError = () => {
      runtimeErrorSeen = true;
    };
    window.addEventListener("error", onRuntimeError);
    window.addEventListener("unhandledrejection", onRuntimeError);

    const hasAnyVisibleContent = () => {
      const rootStyles = window.getComputedStyle(main);
      const rootRect = main.getBoundingClientRect();

      if (
        rootStyles.display === "none" ||
        rootStyles.visibility === "hidden" ||
        parseFloat(rootStyles.opacity || "1") < 0.05 ||
        rootRect.width < 40 ||
        rootRect.height < 40
      ) {
        return false;
      }

      const candidates = main.querySelectorAll(
        "section, article, h1, h2, h3, p, img, video, canvas, svg, [class*='card'], [class*='grid'], [class*='hero'], [class*='content']",
      );

      for (const node of candidates) {
        const el = node as HTMLElement;
        const styles = window.getComputedStyle(el);
        if (
          styles.display === "none" ||
          styles.visibility === "hidden" ||
          parseFloat(styles.opacity || "1") < 0.05
        ) {
          continue;
        }

        const rect = el.getBoundingClientRect();
        const hasSize = rect.width > 24 && rect.height > 16;
        if (hasSize) {
          return true;
        }
      }

      return false;
    };

    const runCheck = () => {
      const visibleNow = hasAnyVisibleContent();
      if (visibleNow) hadVisibleMainContent = true;

      const collapsedAfterRender = hadVisibleMainContent && !visibleNow;
      const errorAndBlank = runtimeErrorSeen && !visibleNow;
      const isAnomaly = collapsedAfterRender || errorAndBlank;

      if (isAnomaly) {
        anomalyStreak += 1;
        healthyStreak = 0;
      } else {
        healthyStreak += 1;
        anomalyStreak = 0;
      }

      if (anomalyStreak >= 2) showNotice();
      if (healthyStreak >= 2) hideNotice();
    };

    // Allow initial render/hydration to settle before checks.
    const initialDelay = setTimeout(() => {
      runCheck();
      const interval = window.setInterval(runCheck, 3000);

      window.addEventListener(
        "beforeunload",
        () => {
          clearInterval(interval);
          window.removeEventListener("error", onRuntimeError);
          window.removeEventListener("unhandledrejection", onRuntimeError);
        },
        { once: true },
      );
    }, 3500);

    window.addEventListener(
      "beforeunload",
      () => {
        clearTimeout(initialDelay);
      },
      { once: true },
    );
  }

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initRenderStabilityWatchdog);
  } else {
    initRenderStabilityWatchdog();
  }
</script>
